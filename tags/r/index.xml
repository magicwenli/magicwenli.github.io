<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>R on Great Expectations</title><link>/tags/r/</link><description>Recent content in R on Great Expectations</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 10 Nov 2021 17:28:19 +0800</lastBuildDate><atom:link href="/tags/r/index.xml" rel="self" type="application/rss+xml"/><item><title>R语言列表操作和连接MongoDB经验之谈</title><link>/posts/r-lang-useful-tricks/</link><pubDate>Wed, 10 Nov 2021 17:28:19 +0800</pubDate><guid>/posts/r-lang-useful-tricks/</guid><description>RStudio R语言的好处 在做Teamfight Tactics分析时，我先通过Riot&amp;rsquo;s API收集到了许多场次的对局数据。如何将这些复杂的</description><content>
&lt;figure class="center" >
&lt;img src="/img/RStudio.png" alt="RStudio" style="border-radius: 8px;" />
&lt;figcaption class="left" style="color: black; " >RStudio&lt;/figcaption>
&lt;/figure>
&lt;h2 id="r语言的好处">R语言的好处&lt;/h2>
&lt;p>在做Teamfight Tactics分析时，我先通过Riot&amp;rsquo;s API收集到了许多场次的对局数据。如何将这些复杂的数据转换成可以直接使用的数据，方便进行分析呢？&lt;/p>
&lt;p>之前一直用的是Python，思路是通过pymongo包连接MongoDB提取数据，再通过python内建函数进行转换和分析。这样需要不停使用&lt;code>Table[&amp;quot;sub&amp;quot;]['subsub']&lt;/code>这样的格式取得内部结构。这部分内容没有代码提示，需要程序员自行记忆每个&lt;code>Key&lt;/code>对应的结构，不仅麻烦，而且容易出错。可以预计分析数据的时候会用到大量循环，而python的效率让人缺乏信心。再加上后续还有画图步骤，而&lt;code>matplotlib&lt;/code>是一个非常麻烦的东西，我有点害怕。&lt;/p>
&lt;p>也考虑过使用&lt;code>Matlab&lt;/code>，它的好处是不少循环可以转为向量化运算，速度会快不少，而且画图容易。&lt;code>Matlab&lt;/code>的附加功能里有一个&lt;code>Database Toolbox Interface for MongoDB&lt;/code>。我甚至已经使用它进行了一段时间分析了，但后面发现默认生成的&lt;code>.mat&lt;/code>格式转换为其他格式比较困难。而且运行速度也不是很理想，消耗资源很大，400MB的数据量在运算时常常卡死我的电脑。也可能是因为我不常使用它，所有代码本身编写的也不够好。&lt;/p>
&lt;p>最后终于接触到了R语言，这真是个好工具。配合RStudio，顺手又高效。它解决了上面的所有问题，而且内建和社区的函数和包为分析过程提供了很大帮助，为我节省了很多时间。它的一些用法和其他语言显得有些奇怪，理解和熟悉需要一些时间，但R语言的学习绝对物超所值。&lt;/p>
&lt;p>李东风老师的开源R语言教程很好，推荐一下：&lt;a href="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/index.html">https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/index.html&lt;/a>&lt;/p>
&lt;h2 id="r语言的数据类型">R语言的数据类型&lt;/h2>
&lt;h3 id="向量">向量&lt;/h3>
&lt;p>向量是将若干个基础类型&lt;strong>相同&lt;/strong>的值存储在一起，各个元素可以按序号访问。需要注意的是，R语言各种类型的数据结构的下标都是从1开始的。例如&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="1" type="checkbox" />
&lt;label for="1">
&lt;span class="collapsable-code__language">R&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-R" >&lt;code>
# 数值型
marks &amp;lt;- c(10, 6, 4, 7, 8)
x &amp;lt;- c(1:3, 10:13)
# 逻辑型
c(1, 3, 5) &amp;gt; 2 # [1] FALSE TRUE TRUE
# 字符型
s1 &amp;lt;- c(&amp;#39;abc&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;a cat&amp;#39;, NA, &amp;#39;李明&amp;#39;)
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>内建的大多数函数以向量为参数时，会对向量内的元素逐个运算，然后返回一个和原来一样长的向量。&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="2" type="checkbox" />
&lt;label for="2">
&lt;span class="collapsable-code__language">R&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-R" >&lt;code>
sqrt(c(1, 4, 6.25)) # [1] 1.0 2.0 2.5
x &amp;lt;- c(33, 55, 11)
order(x) # [1] 3 1 2
x[order(x)] # [1] 11 33 55
&lt;/code>&lt;/pre>
&lt;/div>
&lt;h3 id="列表">列表&lt;/h3>
&lt;p>R中列表(&lt;code>list&lt;/code>)类型来保存&lt;strong>不同&lt;/strong>类型的数据。一个主要目的是提供R分析结果输出包装：输出一个变量，这个变量包括回归系数、预测值、残差、检验结果等等一系列不能放到规则形状数据结构中的内容。实际上，数据框也是列表的一种，但是数据框要求各列等长，而列表不要求。&lt;/p>
&lt;p>列表可以命名，命名后类似字典，可以通过名字访问。&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="3" type="checkbox" />
&lt;label for="3">
&lt;span class="collapsable-code__language">R&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-R" >&lt;code>
rec &amp;lt;- list(name=&amp;#34;李明&amp;#34;, age=30,
scores=c(85, 76, 90))
rec
## $name
## [1] &amp;#34;李明&amp;#34;
##
## $age
## [1] 30
##
## $scores
## [1] 85 76 90
rec$age # 或 rec[[&amp;#34;age&amp;#34;]]
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>也可以通过下标访问，但需要两重中括号。如果使用单重方括号对列表取子集，结果还是列表而不是列表元素。&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="4" type="checkbox" />
&lt;label for="4">
&lt;span class="collapsable-code__language">R&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-R" >&lt;code>
rec[[3]]
## [1] 85 76 90
rec[[3]][2]
## [1] 76
rec[3]
## $scores
## [1] 85 76 90
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>要删除某个元素，直接将该元素赋值为&lt;code>NULL&lt;/code>；添加元素则是直接为该元素赋值。&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="5" type="checkbox" />
&lt;label for="5">
&lt;span class="collapsable-code__language">R&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-R" >&lt;code>
rec[[&amp;#34;age&amp;#34;]] &amp;lt;- NULL
rec[[&amp;#34;身高&amp;#34;]] &amp;lt;- 178
## $name
## [1] &amp;#34;李明&amp;#34;
##
## $三科分数
## [1] 85 0 90
##
## $身高
## [1] 178
&lt;/code>&lt;/pre>
&lt;/div>
&lt;h3 id="数据框">数据框&lt;/h3>
&lt;p>数据框类似于数据库表或Excel数据表的形式。这样形式的数据在R中叫做数据框(&lt;code>data.frame&lt;/code>)。数据框类似于一个矩阵，有$n$个横行、$p$个纵列，但各列允许有不同类型：数值型向量、因子、字符型向量、日期时间向量。同一列的数据类型相同。数据框是一个特殊的列表，其每个列表元素都是一个长度相同的向量。&lt;/p>
&lt;p>数据框可以说是处理数据的最佳方式，利用它可以轻松按列或按行取值，并且可以直接用向量化的方式计算。&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="6" type="checkbox" />
&lt;label for="6">
&lt;span class="collapsable-code__language">R&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-R" >&lt;code>
d&amp;lt;-data.frame(TraitsComb=character(0),Top4=double(0),Winner=double(0),AvgPlacement=double(0),PickTimes=integer(0))
print(d)
## [1] TraitsComb Top4 Winner AvgPlacement PickTimes
## &amp;lt;0 行&amp;gt; (或0-长度的row.names)
d[1,]&amp;lt;-list(&amp;#34;a&amp;#34;, 1.2, 2.3, 3.4, 5)
print(d)
## TraitsComb Top4 Winner AvgPlacement PickTimes
## 1 a 1.2 2.3 3.4 5
colnames(d)
## [1] &amp;#34;TraitsComb&amp;#34; &amp;#34;Top4&amp;#34; &amp;#34;Winner&amp;#34; &amp;#34;AvgPlacement&amp;#34; &amp;#34;PickTimes&amp;#34;
d$Winner
## [1] 2.3
d[3]
## Winner
## 1 2.3
d[3][1]
## Winner
## 1 2.3
&lt;/code>&lt;/pre>
&lt;/div>
&lt;h2 id="r语言函数">R语言函数&lt;/h2>
&lt;h3 id="字符串">字符串&lt;/h3>
&lt;p>观察下面的例子，只用了1行代码就实现了我想要的字符串拼接。&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="364852179" type="checkbox" />
&lt;label for="364852179">
&lt;span class="collapsable-code__language">R&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-R" >&lt;code>
tiers&amp;lt;-rev(c(&amp;#34;DIAMOND&amp;#34;,&amp;#34;PLATINUM&amp;#34;,&amp;#34;GOLD&amp;#34;,&amp;#34;SILVER&amp;#34;,&amp;#34;BRONZE&amp;#34;,&amp;#34;IRON&amp;#34;))
ranks&amp;lt;-rev(c(&amp;#34;I&amp;#34;,&amp;#34;II&amp;#34;,&amp;#34;III&amp;#34;,&amp;#34;IV&amp;#34;,&amp;#34;V&amp;#34;))
tire_order&amp;lt;-lapply(tiers,function(x) paste(x,ranks,sep=&amp;#34;-&amp;#34;)) %&amp;gt;% unlist
## [1] &amp;#34;IRON-V&amp;#34; &amp;#34;IRON-IV&amp;#34; &amp;#34;IRON-III&amp;#34; &amp;#34;IRON-II&amp;#34; &amp;#34;IRON-I&amp;#34; &amp;#34;BRONZE-V&amp;#34;
## [7] &amp;#34;BRONZE-IV&amp;#34; &amp;#34;BRONZE-III&amp;#34; &amp;#34;BRONZE-II&amp;#34; &amp;#34;BRONZE-I&amp;#34; &amp;#34;SILVER-V&amp;#34; &amp;#34;SILVER-IV&amp;#34;
## [13] &amp;#34;SILVER-III&amp;#34; &amp;#34;SILVER-II&amp;#34; &amp;#34;SILVER-I&amp;#34; &amp;#34;GOLD-V&amp;#34; &amp;#34;GOLD-IV&amp;#34; &amp;#34;GOLD-III&amp;#34;
## [19] &amp;#34;GOLD-II&amp;#34; &amp;#34;GOLD-I&amp;#34; &amp;#34;PLATINUM-V&amp;#34; &amp;#34;PLATINUM-IV&amp;#34; &amp;#34;PLATINUM-III&amp;#34; &amp;#34;PLATINUM-II&amp;#34;
## [25] &amp;#34;PLATINUM-I&amp;#34; &amp;#34;DIAMOND-V&amp;#34; &amp;#34;DIAMOND-IV&amp;#34; &amp;#34;DIAMOND-III&amp;#34; &amp;#34;DIAMOND-II&amp;#34; &amp;#34;DIAMOND-I&amp;#34;
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>这里&lt;code>lapply&lt;/code>是对列表遍历，将每个元素先赋值为&lt;code>x&lt;/code>，然后应用&lt;code>function(x)&lt;/code>函数。&lt;code>paste&lt;/code>函数是将两个参数连接起来，&lt;code>sep&lt;/code>是连接符。&lt;/p>
&lt;p>&lt;code>%&amp;gt;%&lt;/code>是一个&lt;code>pipe&lt;/code>，它将结果传递给另一个函数作为第一个参数。&lt;code>unlist&lt;/code>是将列表转换为向量。&lt;/p>
&lt;h3 id="排序">排序&lt;/h3>
&lt;p>对一张以下格式的数据框排序，可以使用&lt;code>order&lt;/code>函数。倒序只需要在排序的列名前加&lt;code>-&lt;/code>号。&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="7" type="checkbox" />
&lt;label for="7">
&lt;span class="collapsable-code__language">R&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-R" >&lt;code>
head(traits_comp_discribe)
## TraitsComb Top4 Winner AvgPlacement PickTimes
## 1 Transformer 0.253 0.025 5.696 79
## 2 Bruiser,Cuddly,Glutton,Sister,Transformer 0.922 0.314 2.373 51
## 3 Arcanist,Cuddly 0.662 0.166 3.593 145
## 4 Socialite 0.217 0.024 6.133 83
## 5 Chemtech,Twinshot 0.462 0.154 4.231 13
## 6 Clockwork,Cuddly,Transformer 0.750 0.250 3.875 8
head(traits_comp_discribe[order(-traits_comp_discribe$Top4),])
## TraitsComb Top4 Winner AvgPlacement PickTimes
## 7 Academy,Cuddly,Imperial 1 0.500 3.000 4
## 11 Bruiser,Sister,Socialite 1 0.400 6.400 5
## 32 Cuddly,Glutton,Sister,Socialite 1 0.333 2.000 3
## 34 Mercenary 1 0.071 7.286 14
## 37 Bruiser,Sister,Transformer,Twinshot 1 0.333 3.000 3
## 38 Bodyguard,Cuddly,Syndicate 1 0.250 3.500 4
&lt;/code>&lt;/pre>
&lt;/div>
&lt;h2 id="mongodb">MongoDB&lt;/h2>
&lt;p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富却最像关系数据库的。它提供了一个非常简单的接口，可以让你在简单的程序中操作数据库。&lt;/p>
&lt;p>在R语言中，连接MongoDB可以使用&lt;code>mongolite&lt;/code>库&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="8" type="checkbox" />
&lt;label for="8">
&lt;span class="collapsable-code__language">R&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-R" >&lt;code>
install.packages(&amp;#34;mongolite&amp;#34;)
library(mongolite)
url &amp;lt;- &amp;#34;mongodb://user:pass@site:port&amp;#34;
db&amp;lt;- &amp;#34;tft&amp;#34; # 数据库名
# 连接数据库
s_con &amp;lt;- mongo(collection=&amp;#39;summoner&amp;#39;,
db=db,
url=url)
# 查询数据 （查询等级低于100的召唤师）
summoners &amp;lt;- s_con$find(&amp;#39;{&amp;#34;summonerlevel&amp;#34;: { &amp;#34;$lt&amp;#34;: 100 }}&amp;#39;)
head(summoners)
## id puuid summonerlevel summonertire summonerrank
## 1 4 ******** 66 PLATINUM I
## 2 5 ******** 1 DIAMOND II
## 3 6 ******** 85 MASTER I
## 4 8 ******** 1 PLATINUM IV
## 5 9 ******** 20 PLATINUM II
## 6 12 ******** 19 PLATINUM II
&lt;/code>&lt;/pre>
&lt;/div></content></item></channel></rss>